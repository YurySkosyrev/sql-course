## Введение
Общая структура БД:
![alt text](img/dbms.jpg "dbms")

SQL (Standart Query Language) - язык для взаимодействия с реляционными БД.

Базы данных:

- предназначены для **долговременного** хранения информации
- Позволяют быстро находить нужные данные, так как обладают встроенными системами поиска
- **Реляционные БД** используют табличную структуру для хранения данных, а для работы с ними используется язык SQL

Реляционные - так как между таблицами есть взаимосвязь (relation)

СУБД (система управления базой данных) - приложение которое может выполнять CRUD операции с файлами (каталогами БД) на жестком диске. Организует работу с БД и добавляет дополнительную функциональность.

Каждая СУБД обладает своими отличиями, например, встроенными типами данных.

Так же каждая СУБД снабжена своим процедурным языком программирования и позволяет записывать хранимые процедуры. В современной разработке это не так распространено, потому, что вся логика в основном находится в backend-приложении.

## Подключение к БД

При обращении к сайту в браузере по имени, мы на самом деле обращаемся к ip-адресу. Чтобы не запоминать все адреса была введена DNS (domain name system), по сути это ассоциативный массив из имени сайта и его ip.

На одной машине может быть развернуто несколько приложений, и каждое из них резервирует свой порт.

По умолчанию 80 для http, 443 для https, поэтому при переходе на сайты достаточно ввести только название сайта.

## DDL & DML

![alt text](img/ddl_dml.jpg "dbms")

```sql
CREATE DATABASE company_repository; - создать БД
DROP DATABASE company_repository; - удалить БД
```

Всегда при создании новой БД создаются три sсhema: public, information_schema, pg_catalog.

Schema по умолчанию - public

information_schema, pg_catalog - конфигурационные схемы (аналог JDK, использование классов Math, Array) 
information_schema - информация о таблицах в БД.
pg_catalog - агрегирующие функции, кастомные типы данных.

schema по аналогии с Java - это пакет. Служит для логического разделения таблиц.

При создании таблицы схема указвается через .

```sql
CREATE TABLE company_storage.company (
    id INT PRIMARY KEY ,
    name VARCHAR UNIQUE NOT NULL ,
    date DATE NOT NULL CHECK ( date > '1995-01-01' AND date < '2020-01-01')
);
```

Constraints - ограничения в таблице поддерживающие целостность данных:

- NOT NULL
- UNIQUE - значение уникальное
- CHECK 
- PRIMARY KEY == UNIQUE NOT NULL может быть только один
- FOREIGN KEY

Constraints можно указывать не только после названия колонки, но и в конце, перечисляя в скобках названия колонок, к которым он относится

```sql
    PRIMARY KEY(id, name)
```

## Primary key

Primary key - должен быть UNIQUE и NOT NULL, кроме того ровно одно такое поле для каждой таблицы.

Если указывать тип этого поля INT, то нужно запоминать какие id уже были введены, иначе будем получать ошибку duplicate.

Решение - тип SERIAL (аналог INT), BIGSERIAL(BIGINT), SMALLSERIAL(SMALLINT)

Данный механизм работает благодаря специальной сущности в Postgres - sequences.

Последовательности можно создавать самому - create sequences. Это бывает нужно, если необходимо создать общую последовательно для нескольких таблиц.

Последовательности есть не во всех СУБД, в MySQL их нет, там есть автоинкремент.

Иногда в качестве первичного ключа задают совокупность нескольких столбцов. В этом случае нужно всегда проверять наличие этих полей в БД при доавлении новой записи. Но проще задать Constraint UNIQUE на эти поля

```sql
CREATE TABLE employee
(
    id         INT PRIMARY KEY,
    first_name VARCHAR(128) NOT NULL ,
    last_name  VARCHAR(128) NOT NULL ,
    salary     INT,
    UNIQUE (first_name, last_name)
);
```

## SELECT

```sql
SELECT DISTINCT             -- выбрать единственную запись
    first_name AS f_name,   -- AS в Postgres можно опустить
    last_name AS l_name,
    salary
FROM employee AS empl
ORDER BY first_name, salary DESC -- по умолчанию ASC, сначала по первому полю, потом по второму
LIMIT 2                          -- выбрать ровно две записи
OFFSET 2;                        -- пропустить первые две записи
```

LIMIT и OFFSET поддерживаются не всеми СУБД.

Фильтрация выборки:

WHERE first_name LIKE '%van%'

% - любая последовательность символов. LIKE чувствителен к регистру.

WHERE salary BETWEEN 100 AND 500 - попадает ли выборка в диапазон

WHERE salary IN (100, 200, 300) - находится ли условие в множестве.

Если в колонке есть null, то COUNT не будет учитывать записи с null, а count(*) посчитает колличество всех записей.

CONCAT('a', 'b') - конкатенация строк.

Почти все СУБД поддерживают такую конкатенацию: 'a' || 'b'

now() - текущая дата сервера.

В schema pg_catalog можно посмотреть все доступные функции (routins) и операторы (operator)

## FOREIGN KEY

```sql
company_id INT REFERENCES company (id) ---более предпочтительный вид записи, тип должен совпадать с company_id

FOREIGN KEY (company_id) REFERENCES company
```

Для внешнего ключа никаких индексов автоматически не создаётся. NOT NULL так же нет.

Использование внешнего ключа даёт нам согласованность данных. Мы не можем добавить id компании, которой не существует.
Так же мы не сможем удалить компанию, на которую есть ссылка из другой таблицы.

FOREIGN KEY - это такой же CONSTRAINT как UNIQUE, NOT NULL.

Для проверки поля на NULL используется ключевое слово IS

UNION ALL используется для объединения запросов из нескольких таблиц, либо логически разбитый сложный запрос из одной таблицы. Результаты выборок при этом должны иметь одинаковое колличество столбцов и столбцы должны иметь одинаковый тип.

UNION обрезает дублирующие значения.

## Подзапросы

При использовании подзапроса в FROM необходимо использовать альяс

```sql
SELECT 
    AVG(empl.salary)
FROM (SELECT
          *
      FROM employee
      ORDER BY salary DESC
      LIMIT 2) empl;

SELECT *,
       (select max(salary) from employee) - salary diff
FROM employee;

SELECT *
FROM employee
WHERE company_id IN (select company.id FROM company WHERE date > '2000-01-01');
```

##DELETE

```sql
DELETE FROM employee
WHERE salary = (SELECT MAX(salary) FROM employee);
```

При операции DELETE есть ограничения по FOREIGN KEY.

Возможно задать поведение при удалении главной сущности, на которую ссылается внешний ключ.

```sql
company_id INT REFERENCES company (id) ON DELETE CASCADE

-- NO ACTION, RESTRICT - по сути одно и то же, действия не предпринимаются
-- SET DEFAULT
-- SET NULL
```

## UPDATE

UPDATE и DELETE возвращают только количество строк, которые они обновили.

```sql
UPDATE employee
SET company_id = 2,
    salary = 1000
WHERE id = 1
RETURNING id, first_name || ' ' || last_name as fio; -- поддерживается не всеми СУБД
```

RETURNING может понадобиться при логировании удаленных строк из БД.

## Нормализация баз данных

Нормализация - это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.

Избыточность данных - это когда одни и те же данные хранятся в базе в нескольких местах (таблицах), именно это и приводит к различным аномалиям.

Нормальная форма базы данных - это набор правил и критериев. которым должна отвечать база данных.

Всего 9 нормальных форм
1. Ненормализованная форма или нулевая формальная форма (UNF)
2. Первая нормальная форма (1NF)
3. Вторая нормальная форма (2NF)
4. Третья нормальная форма (3NF)
5. Нормальная форма Бойса-Кодда (BCNF)
6. Четвертая нормальная форма (4NF)
7. Пятая нормальная форма (5NF)
8. Доменно-ключевая нормальная форма (DKNF)
9. Шестая нормальная форма (6NF)

Каждая последующая форма включает в себя ограничения всех предыдущих.

Чем выше форма, тем ниже производительность. Чем более строгая форма, тем более сложный запрос нужно сделать приложению, а то и несколько запросов.

Другими словами нормализация БД означает соблюдение некоторых нормальных форм.

## 1 Нормальная форма

1. В таблице не должно быть дублирующих строк
2. В каждой ячейке таблицы хранится атомарное значение
3. В столбце хранятся данное одного типа

## 2 Нормальная форма

1. Таблица должна находиться в 1 НФ
2. Таблица долна иметь первичный ключ (PRIMARY KEY)
3. Все неключевые столбцы таблицы должны полностью зависить от полного первичного ключа (в случае если он составной) Избыточность первичного ключа.

## 3 Нормальная форма

1. Таблица должна находиться в 2 НФ
2. В таблице должна отсутствовать транзитивная зависимость неключевых столбцов.

Итог:

1НФ - наше внимание нацелено на соблюдение простейших реляционных принципов (нет дублирования и атомарные значения в ячейках)
2НФ - наше внимание нацелено на первичный ключ.
3НФ - наше внимание нацелено на неключевые столбцы.

## Связи между таблицами

1. 1 к 1
2. 1 к N
3. M к N

UML - Unified Model Language

UML - это язык графического описания для объектного моделирования в области разработки программного обеспечения, моделирования бизнес-процессов, системного проектирования и отображения организационных структур.

ERD - Entity Relationship Diagram.

## JOIN

INNER JOIN отсекает все записи, у которых внешний ключ NULL.

LEFT JOIN - отображаются все записи первой таблицы (слева), даже если нет ссылки на вторую таблицу.

RIGHT JOIN - отображаются все записи справа.

FULL JOIN = LEFT JOIN + RIGHT JOIN.

В случае INNER JOIN условия можно указывать как в блоке ON, так и в последующем WHERE.

А в случае других JOIN, даже если указать условия в блоке ON все равно, либо левая, либо правая таблица будет отображена.